# Java Entity Annotations vs SQL: Detailed Reference

This document explains the purpose of each key Java annotation used in entity classes and compares them directly with SQL definitions. The goal is to understand why each annotation is applied and what it corresponds to at the database level. Every decision in the Logic Lens project is driven by clean architecture, readability, and correctness.

---

## @Entity

* **Purpose:** Marks the class as a JPA entity (i.e., a table in the database).
* **SQL Equivalent:** `CREATE TABLE table_name (...);`

## @Table(name = "table\_name")

* **Purpose:** Specifies the name of the table in the database.
* **Why:** By default, JPA maps class names to table names. This overrides it explicitly for clarity.
* **SQL Equivalent:** `CREATE TABLE table_name (...);`

## @Id

* **Purpose:** Marks a field as the primary key.
* **SQL Equivalent:** `PRIMARY KEY` constraint in `CREATE TABLE`.

## @GeneratedValue(strategy = GenerationType.IDENTITY)

* **Purpose:** Specifies that the primary key should be auto-generated by the database.
* **Why:** For PostgreSQL or MySQL, this aligns with `SERIAL` or `AUTO_INCREMENT`.
* **SQL Equivalent:** `id SERIAL PRIMARY KEY` (PostgreSQL)

## @GeneratedValue

* **Purpose:** Default generation of IDs. When using UUIDs, we skip `strategy`.
* **SQL Equivalent:** `id UUID PRIMARY KEY DEFAULT uuid_generate_v4()` (or handled in Java code)

## @Column(...)

* **Purpose:** Maps a field to a database column with constraints.
* **Attributes:**

    * `nullable = false` → Column must have a value (SQL: `NOT NULL`)
    * `unique = true` → Ensures all values are unique (SQL: `UNIQUE`)
    * `name = "..."` → Overrides default column name (uses field name otherwise)
* **SQL Equivalent:**

```sql
name VARCHAR(100) NOT NULL UNIQUE
```

## @Lob

* **Purpose:** Used for large objects such as code or long text (e.g., Markdown, JSON).
* **SQL Equivalent:** `TEXT`, `CLOB`, or `BYTEA` depending on DB and content type
* **Why:** We use this for problem descriptions, input/output data, and code.

## @ManyToOne

* **Purpose:** Creates a many-to-one relationship (foreign key constraint).
* **Why:** A problem belongs to one category; many problems can belong to the same category.
* **SQL Equivalent:**

```sql
category_id INT REFERENCES categories(id)
```

## @JoinColumn(name = "...")

* **Purpose:** Defines the foreign key column and its name.
* **Why:** Explicit naming avoids default JPA naming, improves readability.
* **SQL Equivalent:** Foreign key definition in `CREATE TABLE`.

## @ManyToMany

* **Purpose:** Creates a many-to-many relationship.
* **Used With:** `@JoinTable(...)` to define the join table manually.
* **SQL Equivalent:**

```sql
CREATE TABLE problem_tags (
  problem_id UUID REFERENCES problems(id),
  tag_id INT REFERENCES tags(id),
  PRIMARY KEY (problem_id, tag_id)
);
```

## @JoinTable

* **Purpose:** Specifies the join table for a many-to-many mapping.
* **Attributes:**

    * `name` → name of the join table
    * `joinColumns` → current entity’s reference
    * `inverseJoinColumns` → target entity’s reference

## @OneToMany

* **Purpose:** Represents the reverse of a `@ManyToOne` relationship.
* **Mapped By:** Used to declare ownership.
* **Why:** For example, a Problem can have multiple TestCases.

## @Builder

* **From Lombok:** Allows clean object creation via builder pattern.
* **Why:** Encourages immutable-like style and readability.

## @Getter / @Setter

* **From Lombok:** Auto-generates getter and setter methods.
* **Why:** Reduces boilerplate code.

## @NoArgsConstructor / @AllArgsConstructor

* **From Lombok:** Auto-generates constructors.
* **Why:** Required for JPA entity instantiation and custom use.

## Composite Key (`@IdClass`)

* **Used in:** Join table entities like `ProblemTag`.
* **Why:** To define a composite primary key class.
* **SQL Equivalent:**

```sql
PRIMARY KEY (problem_id, tag_id)
```

## UUID in Entity

* **Why:** Ensures globally unique identifiers across distributed systems.
* **Java:** Use `@GeneratedValue` without strategy for UUID.
* **SQL Equivalent:**

```sql
id UUID PRIMARY KEY
```

In PostgreSQL, make sure UUID extension is enabled:

```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

---

## Summary Table: Annotation vs SQL

| Java Annotation             | SQL Equivalent/Explanation          |
|-----------------------------|-------------------------------------|
| `@Entity`                   | `CREATE TABLE`                      |
| `@Table(name = "...")`      | Defines table name explicitly       |
| `@Id`                       | `PRIMARY KEY`                       |
| `@GeneratedValue(...)`      | `SERIAL`, `AUTO_INCREMENT`, or UUID |
| `@Column(unique = true)`    | `UNIQUE`                            |
| `@Column(nullable = false)` | `NOT NULL`                          |
| `@Lob`                      | `TEXT` or `CLOB`                    |
| `@ManyToOne`                | `FOREIGN KEY`                       |
| `@JoinColumn`               | FK column in `CREATE TABLE`         |
| `@ManyToMany`               | Requires a join table               |
| `@JoinTable(...)`           | `CREATE TABLE join_table (...)`     |
| `@IdClass`                  | Composite primary key definition    |
| Lombok Annotations          | Code generation (no SQL equivalent) |

---

This annotation style and schema mapping guide will be consistently followed throughout the Logic Lens backend for clarity, correctness, and maintainability.
